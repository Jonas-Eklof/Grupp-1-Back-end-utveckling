JWT_SECRET=superhemlig-nyckel


# JWT_SECRET - en "hemlig nyckel" som används för att signera (skapa) och verifiera tokens


### Hur JWT-token skapas (signeras) med .env-nyckeln
# När en användare loggar in genereras en token med hjälp av JWT_SECRET:

# const jwt = require('jsonwebtoken');

# function generateToken(user) {
#   return jwt.sign(
#     { id: user.id, email: user.email }, // Payload (användardata)
#     process.env.JWT_SECRET,             // Hemlig nyckel från .env
#     { expiresIn: process.env.JWT_EXPIRES_IN } // Token går ut efter 1h
#   );
# }

# // Används i login-routen:
# app.post('/login', (req, res) => {
#   const user = { id: 1, email: 'test@example.com' }; // Hämta från DB i verkligheten
#   const token = generateToken(user);
#   res.json({ token });
# });
# Vad händer här?

# jwt.sign() skapar en krypterad token med användardata (payload).

# process.env.JWT_SECRET används för att signera token (endast din server känner till denna nyckel).

# expiresIn gör att token blir ogiltig efter en viss tid (t.ex. 1h).



### Hur JWT-token verifieras med .env-nyckeln
# När en användare skickar en token (t.ex. i Authorization-headern) måste den verifieras med samma hemliga nyckel (JWT_SECRET). Detta görs i din authenticateToken-middleware:

# function authenticateToken(req, res, next) {
#   const token = req.header('Authorization')?.split(' ')[1];
#   if (!token) return res.status(401).json({ error: 'Åtkomst nekad' });

#   jwt.verify(token, process.env.JWT_SECRET, (err, user) => {
#     if (err) return res.status(403).json({ error: 'Ogiltig token' });
#     req.user = user; // Sparar användardata i request-objektet
#     next();
#   });
# }